var N = null;var searchIndex = {};
searchIndex["finchers_session"]={"doc":"Session support for Finchers.","items":[[3,"Session","finchers_session","A struct which manages the session value per request.",N,N],[11,"fmt","","",0,[[["self"],["formatter"]],["result"]]],[11,"new","","",0,[[["s"]],["session"]]],[11,"get","","Get the session value if available.",0,[[["self"]],["option",["str"]]]],[11,"set","","Set the session value.",0,N],[11,"remove","","Annotates to remove session value to the backend.",0,[[["self"]]]],[11,"with","","",0,N],[11,"into_future","","",0,N],[0,"cookie","","The session backend using Cookie as a session storage.",N,N],[3,"CookieBackend","finchers_session::cookie","",N,N],[3,"CookieSession","","",N,N],[5,"plain","","Create a `CookieSessionBackend` without signing and encryption.",N,[[],["cookiebackend"]]],[5,"signed","","Create a `CookieSessionBackend` with signing (requires `feature = \"secure\"`).",N,N],[5,"private","","Create a `CookieSessionBackend` with encryption (requires `feature = \"secure\"`).",N,N],[11,"fmt","","",1,[[["self"],["formatter"]],["result"]]],[11,"clone","","",1,[[["self"]],["cookiebackend"]]],[11,"plain","","Creates a `CookieSessionBackend` which stores the Cookie values as a raw form.",1,[[],["cookiebackend"]]],[11,"signed","","Creates a `CookieSessionBackend` which signs the Cookie values with the specified secret key.",1,[[["key"]],["cookiebackend"]]],[11,"private","","Creates a `CookieSessionBackend` which encrypts the Cookie values with the specified secret key.",1,[[["key"]],["cookiebackend"]]],[11,"path","","Sets the path of Cookie entry.",1,N],[11,"secure","","Sets the value of `secure` in Cookie entry.",1,[[["self"],["bool"]],["cookiebackend"]]],[11,"http_only","","Sets the value of `http_only` in Cookie entry.",1,[[["self"],["bool"]],["cookiebackend"]]],[11,"domain","","Sets the value of `domain` in Cookie entry.",1,N],[11,"same_site","","Sets the value of `same_site` in Cookie entry.",1,[[["self"],["samesite"]],["cookiebackend"]]],[11,"max_age","","Sets the value of `max_age` in Cookie entry.",1,[[["self"],["duration"]],["cookiebackend"]]],[11,"apply","","",1,[[["self"],["applycontext"]],["applyresult"]]],[11,"fmt","","",2,[[["self"],["formatter"]],["result"]]],[11,"get","","",2,[[["self"]],["option",["str"]]]],[11,"set","","",2,[[["self"],["string"]]]],[11,"remove","","",2,[[["self"]]]],[11,"write","","",2,N],[0,"in_memory","finchers_session","The session backend using in-memory database.",N,N],[3,"InMemoryBackend","finchers_session::in_memory","",N,N],[3,"InMemorySession","","",N,N],[11,"fmt","","",3,[[["self"],["formatter"]],["result"]]],[11,"clone","","",3,[[["self"]],["inmemorybackend"]]],[11,"default","","",3,[[],["inmemorybackend"]]],[11,"apply","","",3,[[["self"],["applycontext"]],["applyresult"]]],[11,"fmt","","",4,[[["self"],["formatter"]],["result"]]],[11,"get","","",4,[[["self"]],["option",["str"]]]],[11,"set","","",4,[[["self"],["string"]]]],[11,"remove","","",4,[[["self"]]]],[11,"write","","",4,N],[0,"redis","finchers_session","The session backend using Redis.",N,N],[3,"RedisBackend","finchers_session::redis","The instance of `SessionBackend` which uses Redis.",N,N],[3,"RedisSession","","",N,N],[11,"fmt","","",5,[[["self"],["formatter"]],["result"]]],[11,"clone","","",5,[[["self"]],["redisbackend"]]],[11,"new","","Create a new `RedisSessionBackend` from the specified Redis client.",5,[[["client"]],["redisbackend"]]],[11,"key_prefix","","Set the prefix string used in the key name when stores the session value to Redis.",5,N],[11,"cookie_name","","Set the name of Cookie entry which stores the session id.",5,N],[11,"timeout","","Set the timeout of session value.",5,[[["self"],["duration"]],["redisbackend"]]],[11,"apply","","",5,[[["self"],["applycontext"]],["applyresult"]]],[11,"fmt","","",6,[[["self"],["formatter"]],["result"]]],[11,"get","","",6,[[["self"]],["option",["str"]]]],[11,"set","","",6,[[["self"],["string"]]]],[11,"remove","","",6,[[["self"]]]],[11,"write","","",6,N],[8,"RawSession","finchers_session","The trait representing the backend to manage session value.",N,N],[16,"WriteFuture","","",7,N],[10,"get","","",7,[[["self"]],["option",["str"]]]],[10,"set","","",7,[[["self"],["string"]]]],[10,"remove","","",7,[[["self"]]]],[10,"write","","",7,N]],"paths":[[3,"Session"],[3,"CookieBackend"],[3,"CookieSession"],[3,"InMemoryBackend"],[3,"InMemorySession"],[3,"RedisBackend"],[3,"RedisSession"],[8,"RawSession"]]};
searchIndex["redis"]={"doc":"redis-rs is a rust implementation of a Redis client library.  It exposes a general purpose interface to Redis and also provides specific helpers for commonly used functionality.","items":[[3,"Client","redis","The client type.",N,N],[3,"Cmd","","Represents redis commands.",N,N],[3,"Iter","","Represents a redis iterator.",N,N],[3,"Pipeline","","Represents a redis command pipeline.",N,N],[3,"Connection","","Represents a stateful redis TCP connection.",N,N],[3,"ConnectionInfo","","Holds the connection information that redis should use for connecting.",N,N],[12,"addr","","A boxed connection address for where to connect to.",0,N],[12,"db","","The database number to use.  This is usually `0`.",0,N],[12,"passwd","","Optionally a password that should be used for connection.",0,N],[3,"Msg","","Represents a pubsub message.",N,N],[3,"PubSub","","Represents a pubsub connection.",N,N],[3,"Parser","","The internal redis response parser.",N,N],[3,"Script","","Represents a lua script.",N,N],[3,"ScriptInvocation","","Represents a prepared script call.",N,N],[3,"InfoDict","","An info dictionary type.",N,N],[3,"RedisError","","Represents a redis error.  For the most part you should be using the Error trait to interact with this rather than the actual struct.",N,N],[4,"ControlFlow","","Allows pubsub callbacks to stop receiving messages.",N,N],[13,"Continue","","",1,N],[13,"Break","","",1,N],[4,"ConnectionAddr","","Defines the connection address.",N,N],[13,"Tcp","","Format for this is `(host, port)`.",2,N],[13,"Unix","","Format for this is the path to the unix socket.",2,N],[4,"ErrorKind","","An enum of all error kinds.",N,N],[13,"ResponseError","","The server generated an invalid response.",3,N],[13,"AuthenticationFailed","","The authentication with the server failed.",3,N],[13,"TypeError","","Operation failed because of a type mismatch.",3,N],[13,"ExecAbortError","","A script execution was aborted.",3,N],[13,"BusyLoadingError","","The server cannot response because it's loading a dump.",3,N],[13,"NoScriptError","","A script that was requested does not actually exist.",3,N],[13,"InvalidClientConfig","","An error that was caused because the parameter to the client were wrong.",3,N],[13,"IoError","","This kind is returned if the redis error is one that is not native to the system.  This is usually the case if the cause is another error.",3,N],[13,"ExtensionError","","An extension error.  This is an error created by the server that is not directly understood by the library.",3,N],[4,"NumericBehavior","","Helper enum that is used in some situations to describe the behavior of arguments in a numeric context.",N,N],[13,"NonNumeric","","",4,N],[13,"NumberIsInteger","","",4,N],[13,"NumberIsFloat","","",4,N],[4,"Value","","Internal low-level redis value enum.",N,N],[13,"Nil","","A nil response from the server.",5,N],[13,"Int","","An integer response.  Note that there are a few situations in which redis actually returns a string for an integer which is why this library generally treats integers and strings the same for all numeric responses.",5,N],[13,"Data","","An arbitary binary data.",5,N],[13,"Bulk","","A bulk response of more data.  This is generally used by redis to express nested structures.",5,N],[13,"Status","","A status response.",5,N],[13,"Okay","","A status response which represents the string \"OK\".",5,N],[5,"cmd","","Shortcut function to creating a command with a single argument.",N,[[["str"]],["cmd"]]],[5,"pack_command","","Packs a bunch of commands into a request.  This is generally a quite useless function as this functionality is nicely wrapped through the `Cmd` object, but in some cases it can be useful.  The return value of this can then be send to the low level `ConnectionLike` methods.",N,N],[5,"pipe","","Shortcut for creating a new pipeline.",N,[[],["pipeline"]]],[5,"parse_redis_url","","This function takes a redis URL string and parses it into a URL as used by rust-url.  This is necessary as the default parser does not understand how redis URLs function.",N,[[["str"]],["result",["url"]]]],[5,"transaction","","This function simplifies transaction management slightly.  What it does is automatically watching keys and then going into a transaction loop util it succeeds.  Once it goes through the results are returned.",N,N],[5,"parse_async","","",N,[[["r"]],["valuefuture"]]],[5,"parse_redis_value","","Parses bytes into a redis value.",N,N],[5,"from_redis_value","","A shortcut function to invoke `FromRedisValue::from_redis_value` to make the API slightly nicer.",N,[[["value"]],["redisresult"]]],[0,"async","","",N,N],[3,"Connection","redis::async","Represents a stateful redis TCP connection.",N,N],[3,"SharedConnection","","",N,N],[5,"connect","","",N,[[["connectioninfo"]],["redisfuture",["connection"]]]],[8,"ConnectionLike","","",N,N],[10,"req_packed_command","","Sends an already encoded (packed) command into the TCP socket and reads the single response from it.",6,[[["self"],["vec",["u8"]]],["redisfuture"]]],[10,"req_packed_commands","","Sends multiple already encoded (packed) command into the TCP socket and reads `count` responses from it.  This is used to implement pipelining.",6,[[["self"],["vec",["u8"]],["usize"],["usize"]],["redisfuture"]]],[10,"get_db","","Returns the database this connection is bound to.  Note that this information might be unreliable because it's initially cached and also might be incorrect if the connection like object is not actually connected.",6,[[["self"]],["i64"]]],[11,"read_response","","",7,[[["self"]],["redisfuture"]]],[11,"req_packed_command","","",7,[[["self"],["vec",["u8"]]],["redisfuture"]]],[11,"req_packed_commands","","",7,[[["self"],["vec",["u8"]],["usize"],["usize"]],["redisfuture"]]],[11,"get_db","","",7,[[["self"]],["i64"]]],[11,"clone","","",8,[[["self"]],["sharedconnection"]]],[11,"new","","",8,[[["connection"]],["redisfuture"]]],[11,"req_packed_command","","",8,[[["self"],["vec",["u8"]]],["redisfuture"]]],[11,"req_packed_commands","","",8,[[["self"],["vec",["u8"]],["usize"],["usize"]],["redisfuture"]]],[11,"get_db","","",8,[[["self"]],["i64"]]],[11,"fmt","redis","",9,[[["self"],["formatter"]],["result"]]],[11,"clone","","",9,[[["self"]],["client"]]],[11,"open","","Connects to a redis server and returns a client.  This does not actually open a connection yet but it does perform some basic checks on the URL that might make the operation fail.",9,[[["t"]],["redisresult",["client"]]]],[11,"get_connection","","Instructs the client to actually connect to redis and returns a connection object.  The connection object can be used to send commands to the server.  This can fail with a variety of errors (like unreachable host) so it's important that you handle those errors.",9,[[["self"]],["redisresult",["connection"]]]],[11,"get_async_connection","","",9,[[["self"]],["redisfuture",["connection"]]]],[11,"get_shared_async_connection","","",9,[[["self"]],["redisfuture",["sharedconnection"]]]],[11,"req_packed_command","","",9,N],[11,"req_packed_commands","","",9,N],[11,"get_db","","",9,[[["self"]],["i64"]]],[11,"clone","","",10,[[["self"]],["cmd"]]],[11,"next","","",11,[[["self"]],["option"]]],[11,"new","","Creates a new empty command.",10,[[],["cmd"]]],[11,"arg","","Appends an argument to the command.  The argument passed must be a type that implements `ToRedisArgs`.  Most primitive types as well as vectors of primitive types implement it.",10,[[["self"],["t"]],["cmd"]]],[11,"cursor_arg","","Works similar to `arg` but adds a cursor argument.  This is always an integer and also flips the command implementation to support a different mode for the iterators where the iterator will ask for another batch of items when the local data is exhausted.",10,[[["self"],["u64"]],["cmd"]]],[11,"get_packed_command","","Returns the packed command as a byte vector.",10,[[["self"]],["vec",["u8"]]]],[11,"in_scan_mode","","Returns true if the command is in scan mode.",10,[[["self"]],["bool"]]],[11,"query","","Sends the command as query to the connection and converts the result to the target redis value.  This is the general way how you can retrieve data.",10,[[["self"],["connectionlike"]],["redisresult"]]],[11,"query_async","","",10,[[["self"],["c"]],["redisfuture"]]],[11,"iter","","Similar to `query()` but returns an iterator over the items of the bulk result or iterator.  In normal mode this is not in any way more efficient than just querying into a `Vec<T>` as it's internally implemented as buffering into a vector.  This however is useful when `cursor_arg` was used in which case the iterator will query for more items until the server side cursor is exhausted.",10,[[["self"],["connectionlike"]],["redisresult",["iter"]]]],[11,"execute","","This is a shortcut to `query()` that does not return a value and will fail the task if the query fails because of an error.  This is mainly useful in examples and for simple commands like setting keys.",10,[[["self"],["connectionlike"]]]],[11,"new","","Creates an empty pipeline.  For consistency with the `cmd` api a `pipe` function is provided as alias.",12,[[],["pipeline"]]],[11,"cmd","","Starts a new command.  Functions such as `arg` then become available to add more arguments to that command.",12,[[["self"],["str"]],["pipeline"]]],[11,"add_command","","Adds a command to the pipeline.",12,[[["self"],["cmd"]],["pipeline"]]],[11,"arg","","Adds an argument to the last started command.  This works similar to the `arg` method of the `Cmd` object.",12,[[["self"],["t"]],["pipeline"]]],[11,"ignore","","Instructs the pipeline to ignore the return value of this command. It will still be ensured that it is not an error, but any successful result is just thrown away.  This makes result processing through tuples much easier because you do not need to handle all the items you do not care about.",12,[[["self"]],["pipeline"]]],[11,"atomic","","This enables atomic mode.  In atomic mode the whole pipeline is enclosed in `MULTI`/`EXEC`.  From the user's point of view nothing changes however.  This is easier than using `MULTI`/`EXEC` yourself as the format does not change.",12,[[["self"]],["pipeline"]]],[11,"query","","Executes the pipeline and fetches the return values.  Since most pipelines return different types it's recommended to use tuple matching to process the results:",12,[[["self"],["connectionlike"]],["redisresult"]]],[11,"query_async","","",12,[[["self"],["c"]],["redisfuture"]]],[11,"execute","","This is a shortcut to `query()` that does not return a value and will fail the task if the query of the pipeline fails.",12,[[["self"],["connectionlike"]]]],[11,"subscribe","","",13,[[["self"],["c"],["f"]],["redisresult"]]],[11,"psubscribe","","",13,[[["self"],["p"],["f"]],["redisresult"]]],[11,"perform","","",12,[[["self"],["cmd"]],["pipeline"]]],[11,"clone","","",2,[[["self"]],["connectionaddr"]]],[11,"fmt","","",2,[[["self"],["formatter"]],["result"]]],[11,"eq","","",2,[[["self"],["connectionaddr"]],["bool"]]],[11,"ne","","",2,[[["self"],["connectionaddr"]],["bool"]]],[11,"is_supported","","",2,[[["self"]],["bool"]]],[11,"clone","","",0,[[["self"]],["connectioninfo"]]],[11,"fmt","","",0,[[["self"],["formatter"]],["result"]]],[11,"into_connection_info","","",0,[[["self"]],["redisresult",["connectioninfo"]]]],[11,"send_packed_command","","Sends an already encoded (packed) command into the TCP socket and does not read a response.  This is useful for commands like `MONITOR` which yield multiple items.  This needs to be used with care because it changes the state of the connection.",13,N],[11,"recv_response","","Fetches a single response from the connection.  This is useful if used in combination with `send_packed_command`.",13,[[["self"]],["redisresult",["value"]]]],[11,"set_write_timeout","","Sets the write timeout for the connection.",13,[[["self"],["option",["duration"]]],["redisresult"]]],[11,"set_read_timeout","","Sets the read timeout for the connection.",13,[[["self"],["option",["duration"]]],["redisresult"]]],[11,"as_pubsub","","",13,[[["self"]],["pubsub"]]],[11,"is_open","","Returns the connection status.",13,[[["self"]],["bool"]]],[11,"req_packed_command","","",13,N],[11,"req_packed_commands","","",13,N],[11,"get_db","","",13,[[["self"]],["i64"]]],[11,"subscribe","","Subscribes to a new channel.",14,[[["self"],["t"]],["redisresult"]]],[11,"psubscribe","","Subscribes to a new channel with a pattern.",14,[[["self"],["t"]],["redisresult"]]],[11,"unsubscribe","","Unsubscribes from a channel.",14,[[["self"],["t"]],["redisresult"]]],[11,"punsubscribe","","Unsubscribes from a channel with a pattern.",14,[[["self"],["t"]],["redisresult"]]],[11,"get_message","","Fetches the next message from the pubsub connection.  Blocks until a message becomes available.  This currently does not provide a wait not to block :(",14,[[["self"]],["redisresult",["msg"]]]],[11,"set_read_timeout","","Sets the read timeout for the connection.",14,[[["self"],["option",["duration"]]],["redisresult"]]],[11,"drop","","",14,[[["self"]]]],[11,"get_channel","","Returns the channel this message came on.",15,[[["self"]],["redisresult"]]],[11,"get_channel_name","","Convenience method to get a string version of the channel.  Unless your channel contains non utf-8 bytes you can always use this method.  If the channel is not a valid string (which really should not happen) then the return value is `\"?\"`.",15,[[["self"]],["str"]]],[11,"get_payload","","Returns the message's payload in a specific format.",15,[[["self"]],["redisresult"]]],[11,"get_payload_bytes","","Returns the bytes that are the message's payload.  This can be used as an alternative to the `get_payload` function if you are interested in the raw bytes in it.",15,N],[11,"from_pattern","","Returns true if the message was constructed from a pattern subscription.",15,[[["self"]],["bool"]]],[11,"get_pattern","","If the message was constructed from a message pattern this can be used to find out which one.  It's recommended to match against an `Option<String>` so that you do not need to use `from_pattern` to figure out if a pattern was set.",15,[[["self"]],["redisresult"]]],[11,"new","","Creates a new parser that parses the data behind the reader.  More than one value can be behind the reader in which case the parser can be invoked multiple times.  In other words: the stream does not have to be terminated.",16,[[["t"]],["parser"]]],[11,"parse_value","","",16,[[["self"]],["redisresult",["value"]]]],[11,"new","","Creates a new script object.",17,[[["str"]],["script"]]],[11,"get_hash","","Returns the script's SHA1 hash in hexadecimal format.",17,[[["self"]],["str"]]],[11,"key","","Creates a script invocation object with a key filled in.",17,[[["self"],["t"]],["scriptinvocation"]]],[11,"arg","","Creates a script invocation object with an argument filled in.",17,[[["self"],["t"]],["scriptinvocation"]]],[11,"prepare_invoke","","Returns an empty script invocation object.  This is primarily useful for programmatically adding arguments and keys because the type will not change.  Normally you can use `arg` and `key` directly.",17,[[["self"]],["scriptinvocation"]]],[11,"invoke","","Invokes the script directly without arguments.",17,[[["self"],["connectionlike"]],["redisresult"]]],[11,"arg","","Adds a regular argument to the invocation.  This ends up as `ARGV[i]` in the script.",18,[[["self"],["t"]],["scriptinvocation"]]],[11,"key","","Adds a key argument to the invocation.  This ends up as `KEYS[i]` in the script.",18,[[["self"],["t"]],["scriptinvocation"]]],[11,"invoke","","Invokes the script and returns the result.",18,[[["self"],["connectionlike"]],["redisresult"]]],[11,"eq","","",4,[[["self"],["numericbehavior"]],["bool"]]],[11,"clone","","",4,[[["self"]],["numericbehavior"]]],[11,"fmt","","",4,[[["self"],["formatter"]],["result"]]],[11,"eq","","",3,[[["self"],["errorkind"]],["bool"]]],[11,"clone","","",3,[[["self"]],["errorkind"]]],[11,"fmt","","",3,[[["self"],["formatter"]],["result"]]],[11,"eq","","",5,[[["self"],["value"]],["bool"]]],[11,"ne","","",5,[[["self"],["value"]],["bool"]]],[11,"clone","","",5,[[["self"]],["value"]]],[11,"looks_like_cursor","","Checks if the return value looks like it fulfils the cursor protocol.  That means the result is a bulk item of length two with the first one being a cursor and the second a bulk response.",5,[[["self"]],["bool"]]],[11,"fmt","","",5,[[["self"],["formatter"]],["result"]]],[11,"eq","","",19,[[["self"],["rediserror"]],["bool"]]],[11,"from","","",19,[[["error"]],["rediserror"]]],[11,"from","","",19,[[["utf8error"]],["rediserror"]]],[11,"from","","",19,N],[11,"from","","",19,N],[11,"description","","",19,[[["self"]],["str"]]],[11,"cause","","",19,[[["self"]],["option",["error"]]]],[11,"fmt","","",19,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",19,[[["self"],["formatter"]],["result",["error"]]]],[11,"kind","","Returns the kind of the error.",19,[[["self"]],["errorkind"]]],[11,"category","","Returns the name of the error category for display purposes.",19,[[["self"]],["str"]]],[11,"is_io_error","","Indicates that this failure is an IO failure.",19,[[["self"]],["bool"]]],[11,"is_connection_refusal","","Returns true if this error indicates that the connection was refused.  You should generally not rely much on this function unless you are writing unit tests that want to detect if a local server is available.",19,[[["self"]],["bool"]]],[11,"is_timeout","","Returns true if error was caused by I/O time out. Note that this may not be accurate depending on platform.",19,[[["self"]],["bool"]]],[11,"is_connection_dropped","","Returns true if error was caused by a dropped connection.",19,[[["self"]],["bool"]]],[11,"extension_error_code","","Returns the extension error code",19,[[["self"]],["option",["str"]]]],[11,"fmt","","",20,[[["self"],["formatter"]],["result"]]],[11,"new","","Creates a new info dictionary from a string in the response of the INFO command.  Each line is a key, value pair with the key and value separated by a colon (`:`).  Lines starting with a hash (`#`) are ignored.",20,[[["str"]],["infodict"]]],[11,"get","","Fetches a value by key and converts it into the given type. Typical types are `String`, `bool` and integer types.",20,[[["self"],["str"]],["option"]]],[11,"find","","",20,[[["self"],["str"]],["option",["value"]]]],[11,"contains_key","","",20,[[["self"],["str"]],["bool"]]],[11,"len","","",20,[[["self"]],["usize"]]],[11,"from_redis_value","","",5,[[["value"]],["redisresult",["value"]]]],[11,"from_redis_value","","",20,[[["value"]],["redisresult",["infodict"]]]],[6,"RedisFuture","","",N,N],[6,"RedisResult","","Library generic result type.",N,N],[8,"Commands","","Implements common redis commands for connection like objects.  This allows you to send commands straight to a connection or client.  It is also implemented for redis results of clients which makes for very convenient access in some basic cases.",N,N],[11,"get","","Get the value of a key.  If key is a vec this becomes an `MGET`.",21,[[["self"],["k"]],["redisresult"]]],[11,"keys","","Gets all keys matching pattern",21,[[["self"],["k"]],["redisresult"]]],[11,"set","","Set the string value of a key.",21,[[["self"],["k"],["v"]],["redisresult"]]],[11,"set_multiple","","Sets multiple keys to their values.",21,N],[11,"set_ex","","Set the value and expiration of a key.",21,[[["self"],["k"],["v"],["usize"]],["redisresult"]]],[11,"set_nx","","Set the value of a key, only if the key does not exist",21,[[["self"],["k"],["v"]],["redisresult"]]],[11,"mset_nx","","Sets multiple keys to their values failing if at least one already exists.",21,N],[11,"getset","","Set the string value of a key and return its old value.",21,[[["self"],["k"],["v"]],["redisresult"]]],[11,"del","","Delete one or more keys.",21,[[["self"],["k"]],["redisresult"]]],[11,"exists","","Determine if a key exists.",21,[[["self"],["k"]],["redisresult"]]],[11,"expire","","Set a key's time to live in seconds.",21,[[["self"],["k"],["usize"]],["redisresult"]]],[11,"expire_at","","Set the expiration for a key as a UNIX timestamp.",21,[[["self"],["k"],["usize"]],["redisresult"]]],[11,"pexpire","","Set a key's time to live in milliseconds.",21,[[["self"],["k"],["usize"]],["redisresult"]]],[11,"pexpire_at","","Set the expiration for a key as a UNIX timestamp in milliseconds.",21,[[["self"],["k"],["usize"]],["redisresult"]]],[11,"persist","","Remove the expiration from a key.",21,[[["self"],["k"]],["redisresult"]]],[11,"ttl","","Check the expiration time of a key.",21,[[["self"],["k"]],["redisresult"]]],[11,"rename","","Rename a key.",21,[[["self"],["k"],["k"]],["redisresult"]]],[11,"rename_nx","","Rename a key, only if the new key does not exist.",21,[[["self"],["k"],["k"]],["redisresult"]]],[11,"append","","Append a value to a key.",21,[[["self"],["k"],["v"]],["redisresult"]]],[11,"incr","","Increment the numeric value of a key by the given amount.  This issues a `INCRBY` or `INCRBYFLOAT` depending on the type.",21,[[["self"],["k"],["v"]],["redisresult"]]],[11,"setbit","","Sets or clears the bit at offset in the string value stored at key.",21,[[["self"],["k"],["usize"],["bool"]],["redisresult"]]],[11,"getbit","","Returns the bit value at offset in the string value stored at key.",21,[[["self"],["k"],["usize"]],["redisresult"]]],[11,"bitcount","","Count set bits in a string.",21,[[["self"],["k"]],["redisresult"]]],[11,"bitcount_range","","Count set bits in a string in a range.",21,[[["self"],["k"],["usize"],["usize"]],["redisresult"]]],[11,"bit_and","","Perform a bitwise AND between multiple keys (containing string values) and store the result in the destination key.",21,[[["self"],["k"],["k"]],["redisresult"]]],[11,"bit_or","","Perform a bitwise OR between multiple keys (containing string values) and store the result in the destination key.",21,[[["self"],["k"],["k"]],["redisresult"]]],[11,"bit_xor","","Perform a bitwise XOR between multiple keys (containing string values) and store the result in the destination key.",21,[[["self"],["k"],["k"]],["redisresult"]]],[11,"bit_not","","Perform a bitwise NOT of the key (containing string values) and store the result in the destination key.",21,[[["self"],["k"],["k"]],["redisresult"]]],[11,"strlen","","Get the length of the value stored in a key.",21,[[["self"],["k"]],["redisresult"]]],[11,"hget","","Gets a single (or multiple) fields from a hash.",21,[[["self"],["k"],["f"]],["redisresult"]]],[11,"hdel","","Deletes a single (or multiple) fields from a hash.",21,[[["self"],["k"],["f"]],["redisresult"]]],[11,"hset","","Sets a single field in a hash.",21,[[["self"],["k"],["f"],["v"]],["redisresult"]]],[11,"hset_nx","","Sets a single field in a hash if it does not exist.",21,[[["self"],["k"],["f"],["v"]],["redisresult"]]],[11,"hset_multiple","","Sets a multiple fields in a hash.",21,N],[11,"hincr","","Increments a value.",21,[[["self"],["k"],["f"],["d"]],["redisresult"]]],[11,"hexists","","Checks if a field in a hash exists.",21,[[["self"],["k"],["f"]],["redisresult"]]],[11,"hkeys","","Gets all the keys in a hash.",21,[[["self"],["k"]],["redisresult"]]],[11,"hvals","","Gets all the values in a hash.",21,[[["self"],["k"]],["redisresult"]]],[11,"hgetall","","Gets all the fields and values in a hash.",21,[[["self"],["k"]],["redisresult"]]],[11,"hlen","","Gets the length of a hash.",21,[[["self"],["k"]],["redisresult"]]],[11,"blpop","","Remove and get the first element in a list, or block until one is available.",21,[[["self"],["k"],["usize"]],["redisresult"]]],[11,"brpop","","Remove and get the last element in a list, or block until one is available.",21,[[["self"],["k"],["usize"]],["redisresult"]]],[11,"brpoplpush","","Pop a value from a list, push it to another list and return it; or block until one is available.",21,[[["self"],["k"],["k"],["usize"]],["redisresult"]]],[11,"lindex","","Get an element from a list by its index.",21,[[["self"],["k"],["isize"]],["redisresult"]]],[11,"linsert_before","","Insert an element before another element in a list.",21,[[["self"],["k"],["p"],["v"]],["redisresult"]]],[11,"linsert_after","","Insert an element after another element in a list.",21,[[["self"],["k"],["p"],["v"]],["redisresult"]]],[11,"llen","","Returns the length of the list stored at key.",21,[[["self"],["k"]],["redisresult"]]],[11,"lpop","","Removes and returns the first element of the list stored at key.",21,[[["self"],["k"]],["redisresult"]]],[11,"lpush","","Insert all the specified values at the head of the list stored at key.",21,[[["self"],["k"],["v"]],["redisresult"]]],[11,"lpush_exists","","Inserts a value at the head of the list stored at key, only if key already exists and holds a list.",21,[[["self"],["k"],["v"]],["redisresult"]]],[11,"lrange","","Returns the specified elements of the list stored at key.",21,[[["self"],["k"],["isize"],["isize"]],["redisresult"]]],[11,"lrem","","Removes the first count occurrences of elements equal to value from the list stored at key.",21,[[["self"],["k"],["isize"],["v"]],["redisresult"]]],[11,"ltrim","","Trim an existing list so that it will contain only the specified range of elements specified.",21,[[["self"],["k"],["isize"],["isize"]],["redisresult"]]],[11,"lset","","Sets the list element at index to value",21,[[["self"],["k"],["isize"],["v"]],["redisresult"]]],[11,"rpop","","Removes and returns the last element of the list stored at key.",21,[[["self"],["k"]],["redisresult"]]],[11,"rpoplpush","","Pop a value from a list, push it to another list and return it.",21,[[["self"],["k"],["k"]],["redisresult"]]],[11,"rpush","","Insert all the specified values at the tail of the list stored at key.",21,[[["self"],["k"],["v"]],["redisresult"]]],[11,"rpush_exists","","Inserts value at the tail of the list stored at key, only if key already exists and holds a list.",21,[[["self"],["k"],["v"]],["redisresult"]]],[11,"sadd","","Add one or more members to a set.",21,[[["self"],["k"],["m"]],["redisresult"]]],[11,"scard","","Get the number of members in a set.",21,[[["self"],["k"]],["redisresult"]]],[11,"sdiff","","Subtract multiple sets.",21,[[["self"],["k"]],["redisresult"]]],[11,"sdiffstore","","Subtract multiple sets and store the resulting set in a key.",21,[[["self"],["k"],["k"]],["redisresult"]]],[11,"sinter","","Intersect multiple sets.",21,[[["self"],["k"]],["redisresult"]]],[11,"sdinterstore","","Intersect multiple sets and store the resulting set in a key.",21,[[["self"],["k"],["k"]],["redisresult"]]],[11,"sismember","","Determine if a given value is a member of a set.",21,[[["self"],["k"],["m"]],["redisresult"]]],[11,"smembers","","Get all the members in a set.",21,[[["self"],["k"]],["redisresult"]]],[11,"smove","","Move a member from one set to another.",21,[[["self"],["k"],["k"],["m"]],["redisresult"]]],[11,"spop","","Remove and return a random member from a set.",21,[[["self"],["k"]],["redisresult"]]],[11,"srandmember","","Get one random member from a set.",21,[[["self"],["k"]],["redisresult"]]],[11,"srandmember_multiple","","Get multiple random members from a set.",21,[[["self"],["k"],["usize"]],["redisresult"]]],[11,"srem","","Remove one or more members from a set.",21,[[["self"],["k"],["m"]],["redisresult"]]],[11,"sunion","","Add multiple sets.",21,[[["self"],["k"]],["redisresult"]]],[11,"sunionstore","","Add multiple sets and store the resulting set in a key.",21,[[["self"],["k"],["k"]],["redisresult"]]],[11,"zadd","","Add one member to a sorted set, or update its score if it already exists.",21,[[["self"],["k"],["m"],["s"]],["redisresult"]]],[11,"zadd_multiple","","Add multiple members to a sorted set, or update its score if it already exists.",21,N],[11,"zcard","","Get the number of members in a sorted set.",21,[[["self"],["k"]],["redisresult"]]],[11,"zcount","","Count the members in a sorted set with scores within the given values.",21,[[["self"],["k"],["m"],["mm"]],["redisresult"]]],[11,"zincr","","Increments the member in a sorted set at key by delta. If the member does not exist, it is added with delta as its score.",21,[[["self"],["k"],["m"],["d"]],["redisresult"]]],[11,"zinterstore","","Intersect multiple sorted sets and store the resulting sorted set in a new key using SUM as aggregation function.",21,N],[11,"zinterstore_min","","Intersect multiple sorted sets and store the resulting sorted set in a new key using MIN as aggregation function.",21,N],[11,"zinterstore_max","","Intersect multiple sorted sets and store the resulting sorted set in a new key using MAX as aggregation function.",21,N],[11,"zlexcount","","Count the number of members in a sorted set between a given lexicographical range.",21,[[["self"],["k"],["l"],["l"]],["redisresult"]]],[11,"zrange","","Return a range of members in a sorted set, by index",21,[[["self"],["k"],["isize"],["isize"]],["redisresult"]]],[11,"zrange_withscores","","Return a range of members in a sorted set, by index with scores.",21,[[["self"],["k"],["isize"],["isize"]],["redisresult"]]],[11,"zrangebylex","","Return a range of members in a sorted set, by lexicographical range.",21,[[["self"],["k"],["m"],["mm"]],["redisresult"]]],[11,"zrangebylex_limit","","Return a range of members in a sorted set, by lexicographical range with offset and limit.",21,[[["self"],["k"],["m"],["mm"],["isize"],["isize"]],["redisresult"]]],[11,"zrevrangebylex","","Return a range of members in a sorted set, by lexicographical range.",21,[[["self"],["k"],["mm"],["m"]],["redisresult"]]],[11,"zrevrangebylex_limit","","Return a range of members in a sorted set, by lexicographical range with offset and limit.",21,[[["self"],["k"],["mm"],["m"],["isize"],["isize"]],["redisresult"]]],[11,"zrangebyscore","","Return a range of members in a sorted set, by score.",21,[[["self"],["k"],["m"],["mm"]],["redisresult"]]],[11,"zrangebyscore_withscores","","Return a range of members in a sorted set, by score with scores.",21,[[["self"],["k"],["m"],["mm"]],["redisresult"]]],[11,"zrangebyscore_limit","","Return a range of members in a sorted set, by score with limit.",21,[[["self"],["k"],["m"],["mm"],["isize"],["isize"]],["redisresult"]]],[11,"zrangebyscore_limit_withscores","","Return a range of members in a sorted set, by score with limit with scores.",21,[[["self"],["k"],["m"],["mm"],["isize"],["isize"]],["redisresult"]]],[11,"zrank","","Determine the index of a member in a sorted set.",21,[[["self"],["k"],["m"]],["redisresult"]]],[11,"zrem","","Remove one or more members from a sorted set.",21,[[["self"],["k"],["m"]],["redisresult"]]],[11,"zrembylex","","Remove all members in a sorted set between the given lexicographical range.",21,[[["self"],["k"],["m"],["mm"]],["redisresult"]]],[11,"zrembyrank","","Remove all members in a sorted set within the given indexes.",21,[[["self"],["k"],["isize"],["isize"]],["redisresult"]]],[11,"zrembyscore","","Remove all members in a sorted set within the given scores.",21,[[["self"],["k"],["m"],["mm"]],["redisresult"]]],[11,"zrevrange","","Return a range of members in a sorted set, by index, with scores ordered from high to low.",21,[[["self"],["k"],["isize"],["isize"]],["redisresult"]]],[11,"zrevrange_withscores","","Return a range of members in a sorted set, by index, with scores ordered from high to low.",21,[[["self"],["k"],["isize"],["isize"]],["redisresult"]]],[11,"zrevrangebyscore","","Return a range of members in a sorted set, by score.",21,[[["self"],["k"],["mm"],["m"]],["redisresult"]]],[11,"zrevrangebyscore_withscores","","Return a range of members in a sorted set, by score with scores.",21,[[["self"],["k"],["mm"],["m"]],["redisresult"]]],[11,"zrevrangebyscore_limit","","Return a range of members in a sorted set, by score with limit.",21,[[["self"],["k"],["mm"],["m"],["isize"],["isize"]],["redisresult"]]],[11,"zrevrangebyscore_limit_withscores","","Return a range of members in a sorted set, by score with limit with scores.",21,[[["self"],["k"],["mm"],["m"],["isize"],["isize"]],["redisresult"]]],[11,"zrevrank","","Determine the index of a member in a sorted set, with scores ordered from high to low.",21,[[["self"],["k"],["m"]],["redisresult"]]],[11,"zscore","","Get the score associated with the given member in a sorted set.",21,[[["self"],["k"],["m"]],["redisresult"]]],[11,"zunionstore","","Unions multiple sorted sets and store the resulting sorted set in a new key using SUM as aggregation function.",21,N],[11,"zunionstore_min","","Unions multiple sorted sets and store the resulting sorted set in a new key using MIN as aggregation function.",21,N],[11,"zunionstore_max","","Unions multiple sorted sets and store the resulting sorted set in a new key using MAX as aggregation function.",21,N],[11,"pfadd","","Adds the specified elements to the specified HyperLogLog.",21,[[["self"],["k"],["e"]],["redisresult"]]],[11,"pfcount","","Return the approximated cardinality of the set(s) observed by the HyperLogLog at key(s).",21,[[["self"],["k"]],["redisresult"]]],[11,"pfmerge","","Merge N different HyperLogLogs into a single one.",21,[[["self"],["k"],["k"]],["redisresult"]]],[11,"publish","","Posts a message to the given channel.",21,[[["self"],["k"],["e"]],["redisresult"]]],[11,"scan","","Incrementally iterate the keys space.",21,[[["self"]],["redisresult",["iter"]]]],[11,"scan_match","","Incrementally iterate the keys space for keys matching a pattern.",21,[[["self"],["p"]],["redisresult",["iter"]]]],[11,"hscan","","Incrementally iterate hash fields and associated values.",21,[[["self"],["k"]],["redisresult",["iter"]]]],[11,"hscan_match","","Incrementally iterate hash fields and associated values for field names matching a pattern.",21,[[["self"],["k"],["p"]],["redisresult",["iter"]]]],[11,"sscan","","Incrementally iterate set elements.",21,[[["self"],["k"]],["redisresult",["iter"]]]],[11,"sscan_match","","Incrementally iterate set elements for elements matching a pattern.",21,[[["self"],["k"],["p"]],["redisresult",["iter"]]]],[11,"zscan","","Incrementally iterate sorted set elements.",21,[[["self"],["k"]],["redisresult",["iter"]]]],[11,"zscan_match","","Incrementally iterate sorted set elements for elements matching a pattern.",21,[[["self"],["k"],["p"]],["redisresult",["iter"]]]],[8,"PipelineCommands","","Implements common redis commands for pipelines.  Unlike the regular commands trait, this returns the pipeline rather than a result directly.  Other than that it works the same however.",N,N],[11,"get","","Get the value of a key.  If key is a vec this becomes an `MGET`.",22,[[["self"],["k"]],["self"]]],[11,"keys","","Gets all keys matching pattern",22,[[["self"],["k"]],["self"]]],[11,"set","","Set the string value of a key.",22,[[["self"],["k"],["v"]],["self"]]],[11,"set_multiple","","Sets multiple keys to their values.",22,N],[11,"set_ex","","Set the value and expiration of a key.",22,[[["self"],["k"],["v"],["usize"]],["self"]]],[11,"set_nx","","Set the value of a key, only if the key does not exist",22,[[["self"],["k"],["v"]],["self"]]],[11,"mset_nx","","Sets multiple keys to their values failing if at least one already exists.",22,N],[11,"getset","","Set the string value of a key and return its old value.",22,[[["self"],["k"],["v"]],["self"]]],[11,"del","","Delete one or more keys.",22,[[["self"],["k"]],["self"]]],[11,"exists","","Determine if a key exists.",22,[[["self"],["k"]],["self"]]],[11,"expire","","Set a key's time to live in seconds.",22,[[["self"],["k"],["usize"]],["self"]]],[11,"expire_at","","Set the expiration for a key as a UNIX timestamp.",22,[[["self"],["k"],["usize"]],["self"]]],[11,"pexpire","","Set a key's time to live in milliseconds.",22,[[["self"],["k"],["usize"]],["self"]]],[11,"pexpire_at","","Set the expiration for a key as a UNIX timestamp in milliseconds.",22,[[["self"],["k"],["usize"]],["self"]]],[11,"persist","","Remove the expiration from a key.",22,[[["self"],["k"]],["self"]]],[11,"ttl","","Check the expiration time of a key.",22,[[["self"],["k"]],["self"]]],[11,"rename","","Rename a key.",22,[[["self"],["k"],["k"]],["self"]]],[11,"rename_nx","","Rename a key, only if the new key does not exist.",22,[[["self"],["k"],["k"]],["self"]]],[11,"append","","Append a value to a key.",22,[[["self"],["k"],["v"]],["self"]]],[11,"incr","","Increment the numeric value of a key by the given amount.  This issues a `INCRBY` or `INCRBYFLOAT` depending on the type.",22,[[["self"],["k"],["v"]],["self"]]],[11,"setbit","","Sets or clears the bit at offset in the string value stored at key.",22,[[["self"],["k"],["usize"],["bool"]],["self"]]],[11,"getbit","","Returns the bit value at offset in the string value stored at key.",22,[[["self"],["k"],["usize"]],["self"]]],[11,"bitcount","","Count set bits in a string.",22,[[["self"],["k"]],["self"]]],[11,"bitcount_range","","Count set bits in a string in a range.",22,[[["self"],["k"],["usize"],["usize"]],["self"]]],[11,"bit_and","","Perform a bitwise AND between multiple keys (containing string values) and store the result in the destination key.",22,[[["self"],["k"],["k"]],["self"]]],[11,"bit_or","","Perform a bitwise OR between multiple keys (containing string values) and store the result in the destination key.",22,[[["self"],["k"],["k"]],["self"]]],[11,"bit_xor","","Perform a bitwise XOR between multiple keys (containing string values) and store the result in the destination key.",22,[[["self"],["k"],["k"]],["self"]]],[11,"bit_not","","Perform a bitwise NOT of the key (containing string values) and store the result in the destination key.",22,[[["self"],["k"],["k"]],["self"]]],[11,"strlen","","Get the length of the value stored in a key.",22,[[["self"],["k"]],["self"]]],[11,"hget","","Gets a single (or multiple) fields from a hash.",22,[[["self"],["k"],["f"]],["self"]]],[11,"hdel","","Deletes a single (or multiple) fields from a hash.",22,[[["self"],["k"],["f"]],["self"]]],[11,"hset","","Sets a single field in a hash.",22,[[["self"],["k"],["f"],["v"]],["self"]]],[11,"hset_nx","","Sets a single field in a hash if it does not exist.",22,[[["self"],["k"],["f"],["v"]],["self"]]],[11,"hset_multiple","","Sets a multiple fields in a hash.",22,N],[11,"hincr","","Increments a value.",22,[[["self"],["k"],["f"],["d"]],["self"]]],[11,"hexists","","Checks if a field in a hash exists.",22,[[["self"],["k"],["f"]],["self"]]],[11,"hkeys","","Gets all the keys in a hash.",22,[[["self"],["k"]],["self"]]],[11,"hvals","","Gets all the values in a hash.",22,[[["self"],["k"]],["self"]]],[11,"hgetall","","Gets all the fields and values in a hash.",22,[[["self"],["k"]],["self"]]],[11,"hlen","","Gets the length of a hash.",22,[[["self"],["k"]],["self"]]],[11,"blpop","","Remove and get the first element in a list, or block until one is available.",22,[[["self"],["k"],["usize"]],["self"]]],[11,"brpop","","Remove and get the last element in a list, or block until one is available.",22,[[["self"],["k"],["usize"]],["self"]]],[11,"brpoplpush","","Pop a value from a list, push it to another list and return it; or block until one is available.",22,[[["self"],["k"],["k"],["usize"]],["self"]]],[11,"lindex","","Get an element from a list by its index.",22,[[["self"],["k"],["isize"]],["self"]]],[11,"linsert_before","","Insert an element before another element in a list.",22,[[["self"],["k"],["p"],["v"]],["self"]]],[11,"linsert_after","","Insert an element after another element in a list.",22,[[["self"],["k"],["p"],["v"]],["self"]]],[11,"llen","","Returns the length of the list stored at key.",22,[[["self"],["k"]],["self"]]],[11,"lpop","","Removes and returns the first element of the list stored at key.",22,[[["self"],["k"]],["self"]]],[11,"lpush","","Insert all the specified values at the head of the list stored at key.",22,[[["self"],["k"],["v"]],["self"]]],[11,"lpush_exists","","Inserts a value at the head of the list stored at key, only if key already exists and holds a list.",22,[[["self"],["k"],["v"]],["self"]]],[11,"lrange","","Returns the specified elements of the list stored at key.",22,[[["self"],["k"],["isize"],["isize"]],["self"]]],[11,"lrem","","Removes the first count occurrences of elements equal to value from the list stored at key.",22,[[["self"],["k"],["isize"],["v"]],["self"]]],[11,"ltrim","","Trim an existing list so that it will contain only the specified range of elements specified.",22,[[["self"],["k"],["isize"],["isize"]],["self"]]],[11,"lset","","Sets the list element at index to value",22,[[["self"],["k"],["isize"],["v"]],["self"]]],[11,"rpop","","Removes and returns the last element of the list stored at key.",22,[[["self"],["k"]],["self"]]],[11,"rpoplpush","","Pop a value from a list, push it to another list and return it.",22,[[["self"],["k"],["k"]],["self"]]],[11,"rpush","","Insert all the specified values at the tail of the list stored at key.",22,[[["self"],["k"],["v"]],["self"]]],[11,"rpush_exists","","Inserts value at the tail of the list stored at key, only if key already exists and holds a list.",22,[[["self"],["k"],["v"]],["self"]]],[11,"sadd","","Add one or more members to a set.",22,[[["self"],["k"],["m"]],["self"]]],[11,"scard","","Get the number of members in a set.",22,[[["self"],["k"]],["self"]]],[11,"sdiff","","Subtract multiple sets.",22,[[["self"],["k"]],["self"]]],[11,"sdiffstore","","Subtract multiple sets and store the resulting set in a key.",22,[[["self"],["k"],["k"]],["self"]]],[11,"sinter","","Intersect multiple sets.",22,[[["self"],["k"]],["self"]]],[11,"sdinterstore","","Intersect multiple sets and store the resulting set in a key.",22,[[["self"],["k"],["k"]],["self"]]],[11,"sismember","","Determine if a given value is a member of a set.",22,[[["self"],["k"],["m"]],["self"]]],[11,"smembers","","Get all the members in a set.",22,[[["self"],["k"]],["self"]]],[11,"smove","","Move a member from one set to another.",22,[[["self"],["k"],["k"],["m"]],["self"]]],[11,"spop","","Remove and return a random member from a set.",22,[[["self"],["k"]],["self"]]],[11,"srandmember","","Get one random member from a set.",22,[[["self"],["k"]],["self"]]],[11,"srandmember_multiple","","Get multiple random members from a set.",22,[[["self"],["k"],["usize"]],["self"]]],[11,"srem","","Remove one or more members from a set.",22,[[["self"],["k"],["m"]],["self"]]],[11,"sunion","","Add multiple sets.",22,[[["self"],["k"]],["self"]]],[11,"sunionstore","","Add multiple sets and store the resulting set in a key.",22,[[["self"],["k"],["k"]],["self"]]],[11,"zadd","","Add one member to a sorted set, or update its score if it already exists.",22,[[["self"],["k"],["m"],["s"]],["self"]]],[11,"zadd_multiple","","Add multiple members to a sorted set, or update its score if it already exists.",22,N],[11,"zcard","","Get the number of members in a sorted set.",22,[[["self"],["k"]],["self"]]],[11,"zcount","","Count the members in a sorted set with scores within the given values.",22,[[["self"],["k"],["m"],["mm"]],["self"]]],[11,"zincr","","Increments the member in a sorted set at key by delta. If the member does not exist, it is added with delta as its score.",22,[[["self"],["k"],["m"],["d"]],["self"]]],[11,"zinterstore","","Intersect multiple sorted sets and store the resulting sorted set in a new key using SUM as aggregation function.",22,N],[11,"zinterstore_min","","Intersect multiple sorted sets and store the resulting sorted set in a new key using MIN as aggregation function.",22,N],[11,"zinterstore_max","","Intersect multiple sorted sets and store the resulting sorted set in a new key using MAX as aggregation function.",22,N],[11,"zlexcount","","Count the number of members in a sorted set between a given lexicographical range.",22,[[["self"],["k"],["l"],["l"]],["self"]]],[11,"zrange","","Return a range of members in a sorted set, by index",22,[[["self"],["k"],["isize"],["isize"]],["self"]]],[11,"zrange_withscores","","Return a range of members in a sorted set, by index with scores.",22,[[["self"],["k"],["isize"],["isize"]],["self"]]],[11,"zrangebylex","","Return a range of members in a sorted set, by lexicographical range.",22,[[["self"],["k"],["m"],["mm"]],["self"]]],[11,"zrangebylex_limit","","Return a range of members in a sorted set, by lexicographical range with offset and limit.",22,[[["self"],["k"],["m"],["mm"],["isize"],["isize"]],["self"]]],[11,"zrevrangebylex","","Return a range of members in a sorted set, by lexicographical range.",22,[[["self"],["k"],["mm"],["m"]],["self"]]],[11,"zrevrangebylex_limit","","Return a range of members in a sorted set, by lexicographical range with offset and limit.",22,[[["self"],["k"],["mm"],["m"],["isize"],["isize"]],["self"]]],[11,"zrangebyscore","","Return a range of members in a sorted set, by score.",22,[[["self"],["k"],["m"],["mm"]],["self"]]],[11,"zrangebyscore_withscores","","Return a range of members in a sorted set, by score with scores.",22,[[["self"],["k"],["m"],["mm"]],["self"]]],[11,"zrangebyscore_limit","","Return a range of members in a sorted set, by score with limit.",22,[[["self"],["k"],["m"],["mm"],["isize"],["isize"]],["self"]]],[11,"zrangebyscore_limit_withscores","","Return a range of members in a sorted set, by score with limit with scores.",22,[[["self"],["k"],["m"],["mm"],["isize"],["isize"]],["self"]]],[11,"zrank","","Determine the index of a member in a sorted set.",22,[[["self"],["k"],["m"]],["self"]]],[11,"zrem","","Remove one or more members from a sorted set.",22,[[["self"],["k"],["m"]],["self"]]],[11,"zrembylex","","Remove all members in a sorted set between the given lexicographical range.",22,[[["self"],["k"],["m"],["mm"]],["self"]]],[11,"zrembyrank","","Remove all members in a sorted set within the given indexes.",22,[[["self"],["k"],["isize"],["isize"]],["self"]]],[11,"zrembyscore","","Remove all members in a sorted set within the given scores.",22,[[["self"],["k"],["m"],["mm"]],["self"]]],[11,"zrevrange","","Return a range of members in a sorted set, by index, with scores ordered from high to low.",22,[[["self"],["k"],["isize"],["isize"]],["self"]]],[11,"zrevrange_withscores","","Return a range of members in a sorted set, by index, with scores ordered from high to low.",22,[[["self"],["k"],["isize"],["isize"]],["self"]]],[11,"zrevrangebyscore","","Return a range of members in a sorted set, by score.",22,[[["self"],["k"],["mm"],["m"]],["self"]]],[11,"zrevrangebyscore_withscores","","Return a range of members in a sorted set, by score with scores.",22,[[["self"],["k"],["mm"],["m"]],["self"]]],[11,"zrevrangebyscore_limit","","Return a range of members in a sorted set, by score with limit.",22,[[["self"],["k"],["mm"],["m"],["isize"],["isize"]],["self"]]],[11,"zrevrangebyscore_limit_withscores","","Return a range of members in a sorted set, by score with limit with scores.",22,[[["self"],["k"],["mm"],["m"],["isize"],["isize"]],["self"]]],[11,"zrevrank","","Determine the index of a member in a sorted set, with scores ordered from high to low.",22,[[["self"],["k"],["m"]],["self"]]],[11,"zscore","","Get the score associated with the given member in a sorted set.",22,[[["self"],["k"],["m"]],["self"]]],[11,"zunionstore","","Unions multiple sorted sets and store the resulting sorted set in a new key using SUM as aggregation function.",22,N],[11,"zunionstore_min","","Unions multiple sorted sets and store the resulting sorted set in a new key using MIN as aggregation function.",22,N],[11,"zunionstore_max","","Unions multiple sorted sets and store the resulting sorted set in a new key using MAX as aggregation function.",22,N],[11,"pfadd","","Adds the specified elements to the specified HyperLogLog.",22,[[["self"],["k"],["e"]],["self"]]],[11,"pfcount","","Return the approximated cardinality of the set(s) observed by the HyperLogLog at key(s).",22,[[["self"],["k"]],["self"]]],[11,"pfmerge","","Merge N different HyperLogLogs into a single one.",22,[[["self"],["k"],["k"]],["self"]]],[11,"publish","","Posts a message to the given channel.",22,[[["self"],["k"],["e"]],["self"]]],[8,"PubSubCommands","","The PubSub trait allows subscribing to one or more channels and receiving a callback whenever a message arrives.",N,N],[10,"subscribe","","Subscribe to a list of channels using SUBSCRIBE and run the provided closure for each message received.",23,[[["self"],["c"],["f"]],["redisresult"]]],[10,"psubscribe","","Subscribe to a list of channels using PSUBSCRIBE and run the provided closure for each message received.",23,[[["self"],["p"],["f"]],["redisresult"]]],[8,"ConnectionLike","","Implements the \"stateless\" part of the connection interface that is used by the different objects in redis-rs.  Primarily it obviously applies to `Connection` object but also some other objects implement the interface (for instance whole clients or certain redis results).",N,N],[10,"req_packed_command","","Sends an already encoded (packed) command into the TCP socket and reads the single response from it.",24,N],[10,"req_packed_commands","","Sends multiple already encoded (packed) command into the TCP socket and reads `count` responses from it.  This is used to implement pipelining.",24,N],[10,"get_db","","Returns the database this connection is bound to.  Note that this information might be unreliable because it's initially cached and also might be incorrect if the connection like object is not actually connected.",24,[[["self"]],["i64"]]],[8,"IntoConnectionInfo","","Converts an object into a connection info struct.  This allows the constructor of the client to accept connection information in a range of different formats.",N,N],[10,"into_connection_info","","",25,[[["self"]],["redisresult",["connectioninfo"]]]],[8,"FromRedisValue","","This trait is used to convert a redis value into a more appropriate type.  While a redis `Value` can represent any response that comes back from the redis server, usually you want to map this into something that works better in rust.  For instance you might want to convert the return value into a `String` or an integer.",N,N],[10,"from_redis_value","","Given a redis `Value` this attempts to convert it into the given destination type.  If that fails because it's not compatible an appropriate error is generated.",26,[[["value"]],["redisresult"]]],[11,"from_redis_values","","Similar to `from_redis_value` but constructs a vector of objects from another vector of values.  This primarily exists internally to customize the behavior for vectors of tuples.",26,N],[8,"ToRedisArgs","","Used to convert a value into one or multiple redis argument strings.  Most values will produce exactly one item but in some cases it might make sense to produce more than one.",N,N],[11,"to_redis_args","","This converts the value into a vector of bytes.  Each item is a single argument.  Most items generate a vector of a single item.",27,[[["self"]],["vec",["vec"]]]],[10,"write_redis_args","","This writes the value into a vector of bytes.  Each item is a single argument.  Most items generate a single item.",27,[[["self"],["vec"]]]],[11,"describe_numeric_behavior","","Returns an information about the contained value with regards to it's numeric behavior in a redis context.  This is used in some high level concepts to switch between different implementations of redis functions (for instance `INCR` vs `INCRBYFLOAT`).",27,[[["self"]],["numericbehavior"]]],[11,"is_single_arg","","Returns an indiciation if the value contained is exactly one argument.  It returns false if it's zero or more than one.  This is used in some high level functions to intelligently switch between `GET` and `MGET` variants.",27,[[["self"]],["bool"]]],[11,"get","","Get the value of a key.  If key is a vec this becomes an `MGET`.",21,[[["self"],["k"]],["redisresult"]]],[11,"keys","","Gets all keys matching pattern",21,[[["self"],["k"]],["redisresult"]]],[11,"set","","Set the string value of a key.",21,[[["self"],["k"],["v"]],["redisresult"]]],[11,"set_multiple","","Sets multiple keys to their values.",21,N],[11,"set_ex","","Set the value and expiration of a key.",21,[[["self"],["k"],["v"],["usize"]],["redisresult"]]],[11,"set_nx","","Set the value of a key, only if the key does not exist",21,[[["self"],["k"],["v"]],["redisresult"]]],[11,"mset_nx","","Sets multiple keys to their values failing if at least one already exists.",21,N],[11,"getset","","Set the string value of a key and return its old value.",21,[[["self"],["k"],["v"]],["redisresult"]]],[11,"del","","Delete one or more keys.",21,[[["self"],["k"]],["redisresult"]]],[11,"exists","","Determine if a key exists.",21,[[["self"],["k"]],["redisresult"]]],[11,"expire","","Set a key's time to live in seconds.",21,[[["self"],["k"],["usize"]],["redisresult"]]],[11,"expire_at","","Set the expiration for a key as a UNIX timestamp.",21,[[["self"],["k"],["usize"]],["redisresult"]]],[11,"pexpire","","Set a key's time to live in milliseconds.",21,[[["self"],["k"],["usize"]],["redisresult"]]],[11,"pexpire_at","","Set the expiration for a key as a UNIX timestamp in milliseconds.",21,[[["self"],["k"],["usize"]],["redisresult"]]],[11,"persist","","Remove the expiration from a key.",21,[[["self"],["k"]],["redisresult"]]],[11,"ttl","","Check the expiration time of a key.",21,[[["self"],["k"]],["redisresult"]]],[11,"rename","","Rename a key.",21,[[["self"],["k"],["k"]],["redisresult"]]],[11,"rename_nx","","Rename a key, only if the new key does not exist.",21,[[["self"],["k"],["k"]],["redisresult"]]],[11,"append","","Append a value to a key.",21,[[["self"],["k"],["v"]],["redisresult"]]],[11,"incr","","Increment the numeric value of a key by the given amount.  This issues a `INCRBY` or `INCRBYFLOAT` depending on the type.",21,[[["self"],["k"],["v"]],["redisresult"]]],[11,"setbit","","Sets or clears the bit at offset in the string value stored at key.",21,[[["self"],["k"],["usize"],["bool"]],["redisresult"]]],[11,"getbit","","Returns the bit value at offset in the string value stored at key.",21,[[["self"],["k"],["usize"]],["redisresult"]]],[11,"bitcount","","Count set bits in a string.",21,[[["self"],["k"]],["redisresult"]]],[11,"bitcount_range","","Count set bits in a string in a range.",21,[[["self"],["k"],["usize"],["usize"]],["redisresult"]]],[11,"bit_and","","Perform a bitwise AND between multiple keys (containing string values) and store the result in the destination key.",21,[[["self"],["k"],["k"]],["redisresult"]]],[11,"bit_or","","Perform a bitwise OR between multiple keys (containing string values) and store the result in the destination key.",21,[[["self"],["k"],["k"]],["redisresult"]]],[11,"bit_xor","","Perform a bitwise XOR between multiple keys (containing string values) and store the result in the destination key.",21,[[["self"],["k"],["k"]],["redisresult"]]],[11,"bit_not","","Perform a bitwise NOT of the key (containing string values) and store the result in the destination key.",21,[[["self"],["k"],["k"]],["redisresult"]]],[11,"strlen","","Get the length of the value stored in a key.",21,[[["self"],["k"]],["redisresult"]]],[11,"hget","","Gets a single (or multiple) fields from a hash.",21,[[["self"],["k"],["f"]],["redisresult"]]],[11,"hdel","","Deletes a single (or multiple) fields from a hash.",21,[[["self"],["k"],["f"]],["redisresult"]]],[11,"hset","","Sets a single field in a hash.",21,[[["self"],["k"],["f"],["v"]],["redisresult"]]],[11,"hset_nx","","Sets a single field in a hash if it does not exist.",21,[[["self"],["k"],["f"],["v"]],["redisresult"]]],[11,"hset_multiple","","Sets a multiple fields in a hash.",21,N],[11,"hincr","","Increments a value.",21,[[["self"],["k"],["f"],["d"]],["redisresult"]]],[11,"hexists","","Checks if a field in a hash exists.",21,[[["self"],["k"],["f"]],["redisresult"]]],[11,"hkeys","","Gets all the keys in a hash.",21,[[["self"],["k"]],["redisresult"]]],[11,"hvals","","Gets all the values in a hash.",21,[[["self"],["k"]],["redisresult"]]],[11,"hgetall","","Gets all the fields and values in a hash.",21,[[["self"],["k"]],["redisresult"]]],[11,"hlen","","Gets the length of a hash.",21,[[["self"],["k"]],["redisresult"]]],[11,"blpop","","Remove and get the first element in a list, or block until one is available.",21,[[["self"],["k"],["usize"]],["redisresult"]]],[11,"brpop","","Remove and get the last element in a list, or block until one is available.",21,[[["self"],["k"],["usize"]],["redisresult"]]],[11,"brpoplpush","","Pop a value from a list, push it to another list and return it; or block until one is available.",21,[[["self"],["k"],["k"],["usize"]],["redisresult"]]],[11,"lindex","","Get an element from a list by its index.",21,[[["self"],["k"],["isize"]],["redisresult"]]],[11,"linsert_before","","Insert an element before another element in a list.",21,[[["self"],["k"],["p"],["v"]],["redisresult"]]],[11,"linsert_after","","Insert an element after another element in a list.",21,[[["self"],["k"],["p"],["v"]],["redisresult"]]],[11,"llen","","Returns the length of the list stored at key.",21,[[["self"],["k"]],["redisresult"]]],[11,"lpop","","Removes and returns the first element of the list stored at key.",21,[[["self"],["k"]],["redisresult"]]],[11,"lpush","","Insert all the specified values at the head of the list stored at key.",21,[[["self"],["k"],["v"]],["redisresult"]]],[11,"lpush_exists","","Inserts a value at the head of the list stored at key, only if key already exists and holds a list.",21,[[["self"],["k"],["v"]],["redisresult"]]],[11,"lrange","","Returns the specified elements of the list stored at key.",21,[[["self"],["k"],["isize"],["isize"]],["redisresult"]]],[11,"lrem","","Removes the first count occurrences of elements equal to value from the list stored at key.",21,[[["self"],["k"],["isize"],["v"]],["redisresult"]]],[11,"ltrim","","Trim an existing list so that it will contain only the specified range of elements specified.",21,[[["self"],["k"],["isize"],["isize"]],["redisresult"]]],[11,"lset","","Sets the list element at index to value",21,[[["self"],["k"],["isize"],["v"]],["redisresult"]]],[11,"rpop","","Removes and returns the last element of the list stored at key.",21,[[["self"],["k"]],["redisresult"]]],[11,"rpoplpush","","Pop a value from a list, push it to another list and return it.",21,[[["self"],["k"],["k"]],["redisresult"]]],[11,"rpush","","Insert all the specified values at the tail of the list stored at key.",21,[[["self"],["k"],["v"]],["redisresult"]]],[11,"rpush_exists","","Inserts value at the tail of the list stored at key, only if key already exists and holds a list.",21,[[["self"],["k"],["v"]],["redisresult"]]],[11,"sadd","","Add one or more members to a set.",21,[[["self"],["k"],["m"]],["redisresult"]]],[11,"scard","","Get the number of members in a set.",21,[[["self"],["k"]],["redisresult"]]],[11,"sdiff","","Subtract multiple sets.",21,[[["self"],["k"]],["redisresult"]]],[11,"sdiffstore","","Subtract multiple sets and store the resulting set in a key.",21,[[["self"],["k"],["k"]],["redisresult"]]],[11,"sinter","","Intersect multiple sets.",21,[[["self"],["k"]],["redisresult"]]],[11,"sdinterstore","","Intersect multiple sets and store the resulting set in a key.",21,[[["self"],["k"],["k"]],["redisresult"]]],[11,"sismember","","Determine if a given value is a member of a set.",21,[[["self"],["k"],["m"]],["redisresult"]]],[11,"smembers","","Get all the members in a set.",21,[[["self"],["k"]],["redisresult"]]],[11,"smove","","Move a member from one set to another.",21,[[["self"],["k"],["k"],["m"]],["redisresult"]]],[11,"spop","","Remove and return a random member from a set.",21,[[["self"],["k"]],["redisresult"]]],[11,"srandmember","","Get one random member from a set.",21,[[["self"],["k"]],["redisresult"]]],[11,"srandmember_multiple","","Get multiple random members from a set.",21,[[["self"],["k"],["usize"]],["redisresult"]]],[11,"srem","","Remove one or more members from a set.",21,[[["self"],["k"],["m"]],["redisresult"]]],[11,"sunion","","Add multiple sets.",21,[[["self"],["k"]],["redisresult"]]],[11,"sunionstore","","Add multiple sets and store the resulting set in a key.",21,[[["self"],["k"],["k"]],["redisresult"]]],[11,"zadd","","Add one member to a sorted set, or update its score if it already exists.",21,[[["self"],["k"],["m"],["s"]],["redisresult"]]],[11,"zadd_multiple","","Add multiple members to a sorted set, or update its score if it already exists.",21,N],[11,"zcard","","Get the number of members in a sorted set.",21,[[["self"],["k"]],["redisresult"]]],[11,"zcount","","Count the members in a sorted set with scores within the given values.",21,[[["self"],["k"],["m"],["mm"]],["redisresult"]]],[11,"zincr","","Increments the member in a sorted set at key by delta. If the member does not exist, it is added with delta as its score.",21,[[["self"],["k"],["m"],["d"]],["redisresult"]]],[11,"zinterstore","","Intersect multiple sorted sets and store the resulting sorted set in a new key using SUM as aggregation function.",21,N],[11,"zinterstore_min","","Intersect multiple sorted sets and store the resulting sorted set in a new key using MIN as aggregation function.",21,N],[11,"zinterstore_max","","Intersect multiple sorted sets and store the resulting sorted set in a new key using MAX as aggregation function.",21,N],[11,"zlexcount","","Count the number of members in a sorted set between a given lexicographical range.",21,[[["self"],["k"],["l"],["l"]],["redisresult"]]],[11,"zrange","","Return a range of members in a sorted set, by index",21,[[["self"],["k"],["isize"],["isize"]],["redisresult"]]],[11,"zrange_withscores","","Return a range of members in a sorted set, by index with scores.",21,[[["self"],["k"],["isize"],["isize"]],["redisresult"]]],[11,"zrangebylex","","Return a range of members in a sorted set, by lexicographical range.",21,[[["self"],["k"],["m"],["mm"]],["redisresult"]]],[11,"zrangebylex_limit","","Return a range of members in a sorted set, by lexicographical range with offset and limit.",21,[[["self"],["k"],["m"],["mm"],["isize"],["isize"]],["redisresult"]]],[11,"zrevrangebylex","","Return a range of members in a sorted set, by lexicographical range.",21,[[["self"],["k"],["mm"],["m"]],["redisresult"]]],[11,"zrevrangebylex_limit","","Return a range of members in a sorted set, by lexicographical range with offset and limit.",21,[[["self"],["k"],["mm"],["m"],["isize"],["isize"]],["redisresult"]]],[11,"zrangebyscore","","Return a range of members in a sorted set, by score.",21,[[["self"],["k"],["m"],["mm"]],["redisresult"]]],[11,"zrangebyscore_withscores","","Return a range of members in a sorted set, by score with scores.",21,[[["self"],["k"],["m"],["mm"]],["redisresult"]]],[11,"zrangebyscore_limit","","Return a range of members in a sorted set, by score with limit.",21,[[["self"],["k"],["m"],["mm"],["isize"],["isize"]],["redisresult"]]],[11,"zrangebyscore_limit_withscores","","Return a range of members in a sorted set, by score with limit with scores.",21,[[["self"],["k"],["m"],["mm"],["isize"],["isize"]],["redisresult"]]],[11,"zrank","","Determine the index of a member in a sorted set.",21,[[["self"],["k"],["m"]],["redisresult"]]],[11,"zrem","","Remove one or more members from a sorted set.",21,[[["self"],["k"],["m"]],["redisresult"]]],[11,"zrembylex","","Remove all members in a sorted set between the given lexicographical range.",21,[[["self"],["k"],["m"],["mm"]],["redisresult"]]],[11,"zrembyrank","","Remove all members in a sorted set within the given indexes.",21,[[["self"],["k"],["isize"],["isize"]],["redisresult"]]],[11,"zrembyscore","","Remove all members in a sorted set within the given scores.",21,[[["self"],["k"],["m"],["mm"]],["redisresult"]]],[11,"zrevrange","","Return a range of members in a sorted set, by index, with scores ordered from high to low.",21,[[["self"],["k"],["isize"],["isize"]],["redisresult"]]],[11,"zrevrange_withscores","","Return a range of members in a sorted set, by index, with scores ordered from high to low.",21,[[["self"],["k"],["isize"],["isize"]],["redisresult"]]],[11,"zrevrangebyscore","","Return a range of members in a sorted set, by score.",21,[[["self"],["k"],["mm"],["m"]],["redisresult"]]],[11,"zrevrangebyscore_withscores","","Return a range of members in a sorted set, by score with scores.",21,[[["self"],["k"],["mm"],["m"]],["redisresult"]]],[11,"zrevrangebyscore_limit","","Return a range of members in a sorted set, by score with limit.",21,[[["self"],["k"],["mm"],["m"],["isize"],["isize"]],["redisresult"]]],[11,"zrevrangebyscore_limit_withscores","","Return a range of members in a sorted set, by score with limit with scores.",21,[[["self"],["k"],["mm"],["m"],["isize"],["isize"]],["redisresult"]]],[11,"zrevrank","","Determine the index of a member in a sorted set, with scores ordered from high to low.",21,[[["self"],["k"],["m"]],["redisresult"]]],[11,"zscore","","Get the score associated with the given member in a sorted set.",21,[[["self"],["k"],["m"]],["redisresult"]]],[11,"zunionstore","","Unions multiple sorted sets and store the resulting sorted set in a new key using SUM as aggregation function.",21,N],[11,"zunionstore_min","","Unions multiple sorted sets and store the resulting sorted set in a new key using MIN as aggregation function.",21,N],[11,"zunionstore_max","","Unions multiple sorted sets and store the resulting sorted set in a new key using MAX as aggregation function.",21,N],[11,"pfadd","","Adds the specified elements to the specified HyperLogLog.",21,[[["self"],["k"],["e"]],["redisresult"]]],[11,"pfcount","","Return the approximated cardinality of the set(s) observed by the HyperLogLog at key(s).",21,[[["self"],["k"]],["redisresult"]]],[11,"pfmerge","","Merge N different HyperLogLogs into a single one.",21,[[["self"],["k"],["k"]],["redisresult"]]],[11,"publish","","Posts a message to the given channel.",21,[[["self"],["k"],["e"]],["redisresult"]]],[11,"scan","","Incrementally iterate the keys space.",21,[[["self"]],["redisresult",["iter"]]]],[11,"scan_match","","Incrementally iterate the keys space for keys matching a pattern.",21,[[["self"],["p"]],["redisresult",["iter"]]]],[11,"hscan","","Incrementally iterate hash fields and associated values.",21,[[["self"],["k"]],["redisresult",["iter"]]]],[11,"hscan_match","","Incrementally iterate hash fields and associated values for field names matching a pattern.",21,[[["self"],["k"],["p"]],["redisresult",["iter"]]]],[11,"sscan","","Incrementally iterate set elements.",21,[[["self"],["k"]],["redisresult",["iter"]]]],[11,"sscan_match","","Incrementally iterate set elements for elements matching a pattern.",21,[[["self"],["k"],["p"]],["redisresult",["iter"]]]],[11,"zscan","","Incrementally iterate sorted set elements.",21,[[["self"],["k"]],["redisresult",["iter"]]]],[11,"zscan_match","","Incrementally iterate sorted set elements for elements matching a pattern.",21,[[["self"],["k"],["p"]],["redisresult",["iter"]]]],[11,"get","","Get the value of a key.  If key is a vec this becomes an `MGET`.",22,[[["self"],["k"]],["self"]]],[11,"keys","","Gets all keys matching pattern",22,[[["self"],["k"]],["self"]]],[11,"set","","Set the string value of a key.",22,[[["self"],["k"],["v"]],["self"]]],[11,"set_multiple","","Sets multiple keys to their values.",22,N],[11,"set_ex","","Set the value and expiration of a key.",22,[[["self"],["k"],["v"],["usize"]],["self"]]],[11,"set_nx","","Set the value of a key, only if the key does not exist",22,[[["self"],["k"],["v"]],["self"]]],[11,"mset_nx","","Sets multiple keys to their values failing if at least one already exists.",22,N],[11,"getset","","Set the string value of a key and return its old value.",22,[[["self"],["k"],["v"]],["self"]]],[11,"del","","Delete one or more keys.",22,[[["self"],["k"]],["self"]]],[11,"exists","","Determine if a key exists.",22,[[["self"],["k"]],["self"]]],[11,"expire","","Set a key's time to live in seconds.",22,[[["self"],["k"],["usize"]],["self"]]],[11,"expire_at","","Set the expiration for a key as a UNIX timestamp.",22,[[["self"],["k"],["usize"]],["self"]]],[11,"pexpire","","Set a key's time to live in milliseconds.",22,[[["self"],["k"],["usize"]],["self"]]],[11,"pexpire_at","","Set the expiration for a key as a UNIX timestamp in milliseconds.",22,[[["self"],["k"],["usize"]],["self"]]],[11,"persist","","Remove the expiration from a key.",22,[[["self"],["k"]],["self"]]],[11,"ttl","","Check the expiration time of a key.",22,[[["self"],["k"]],["self"]]],[11,"rename","","Rename a key.",22,[[["self"],["k"],["k"]],["self"]]],[11,"rename_nx","","Rename a key, only if the new key does not exist.",22,[[["self"],["k"],["k"]],["self"]]],[11,"append","","Append a value to a key.",22,[[["self"],["k"],["v"]],["self"]]],[11,"incr","","Increment the numeric value of a key by the given amount.  This issues a `INCRBY` or `INCRBYFLOAT` depending on the type.",22,[[["self"],["k"],["v"]],["self"]]],[11,"setbit","","Sets or clears the bit at offset in the string value stored at key.",22,[[["self"],["k"],["usize"],["bool"]],["self"]]],[11,"getbit","","Returns the bit value at offset in the string value stored at key.",22,[[["self"],["k"],["usize"]],["self"]]],[11,"bitcount","","Count set bits in a string.",22,[[["self"],["k"]],["self"]]],[11,"bitcount_range","","Count set bits in a string in a range.",22,[[["self"],["k"],["usize"],["usize"]],["self"]]],[11,"bit_and","","Perform a bitwise AND between multiple keys (containing string values) and store the result in the destination key.",22,[[["self"],["k"],["k"]],["self"]]],[11,"bit_or","","Perform a bitwise OR between multiple keys (containing string values) and store the result in the destination key.",22,[[["self"],["k"],["k"]],["self"]]],[11,"bit_xor","","Perform a bitwise XOR between multiple keys (containing string values) and store the result in the destination key.",22,[[["self"],["k"],["k"]],["self"]]],[11,"bit_not","","Perform a bitwise NOT of the key (containing string values) and store the result in the destination key.",22,[[["self"],["k"],["k"]],["self"]]],[11,"strlen","","Get the length of the value stored in a key.",22,[[["self"],["k"]],["self"]]],[11,"hget","","Gets a single (or multiple) fields from a hash.",22,[[["self"],["k"],["f"]],["self"]]],[11,"hdel","","Deletes a single (or multiple) fields from a hash.",22,[[["self"],["k"],["f"]],["self"]]],[11,"hset","","Sets a single field in a hash.",22,[[["self"],["k"],["f"],["v"]],["self"]]],[11,"hset_nx","","Sets a single field in a hash if it does not exist.",22,[[["self"],["k"],["f"],["v"]],["self"]]],[11,"hset_multiple","","Sets a multiple fields in a hash.",22,N],[11,"hincr","","Increments a value.",22,[[["self"],["k"],["f"],["d"]],["self"]]],[11,"hexists","","Checks if a field in a hash exists.",22,[[["self"],["k"],["f"]],["self"]]],[11,"hkeys","","Gets all the keys in a hash.",22,[[["self"],["k"]],["self"]]],[11,"hvals","","Gets all the values in a hash.",22,[[["self"],["k"]],["self"]]],[11,"hgetall","","Gets all the fields and values in a hash.",22,[[["self"],["k"]],["self"]]],[11,"hlen","","Gets the length of a hash.",22,[[["self"],["k"]],["self"]]],[11,"blpop","","Remove and get the first element in a list, or block until one is available.",22,[[["self"],["k"],["usize"]],["self"]]],[11,"brpop","","Remove and get the last element in a list, or block until one is available.",22,[[["self"],["k"],["usize"]],["self"]]],[11,"brpoplpush","","Pop a value from a list, push it to another list and return it; or block until one is available.",22,[[["self"],["k"],["k"],["usize"]],["self"]]],[11,"lindex","","Get an element from a list by its index.",22,[[["self"],["k"],["isize"]],["self"]]],[11,"linsert_before","","Insert an element before another element in a list.",22,[[["self"],["k"],["p"],["v"]],["self"]]],[11,"linsert_after","","Insert an element after another element in a list.",22,[[["self"],["k"],["p"],["v"]],["self"]]],[11,"llen","","Returns the length of the list stored at key.",22,[[["self"],["k"]],["self"]]],[11,"lpop","","Removes and returns the first element of the list stored at key.",22,[[["self"],["k"]],["self"]]],[11,"lpush","","Insert all the specified values at the head of the list stored at key.",22,[[["self"],["k"],["v"]],["self"]]],[11,"lpush_exists","","Inserts a value at the head of the list stored at key, only if key already exists and holds a list.",22,[[["self"],["k"],["v"]],["self"]]],[11,"lrange","","Returns the specified elements of the list stored at key.",22,[[["self"],["k"],["isize"],["isize"]],["self"]]],[11,"lrem","","Removes the first count occurrences of elements equal to value from the list stored at key.",22,[[["self"],["k"],["isize"],["v"]],["self"]]],[11,"ltrim","","Trim an existing list so that it will contain only the specified range of elements specified.",22,[[["self"],["k"],["isize"],["isize"]],["self"]]],[11,"lset","","Sets the list element at index to value",22,[[["self"],["k"],["isize"],["v"]],["self"]]],[11,"rpop","","Removes and returns the last element of the list stored at key.",22,[[["self"],["k"]],["self"]]],[11,"rpoplpush","","Pop a value from a list, push it to another list and return it.",22,[[["self"],["k"],["k"]],["self"]]],[11,"rpush","","Insert all the specified values at the tail of the list stored at key.",22,[[["self"],["k"],["v"]],["self"]]],[11,"rpush_exists","","Inserts value at the tail of the list stored at key, only if key already exists and holds a list.",22,[[["self"],["k"],["v"]],["self"]]],[11,"sadd","","Add one or more members to a set.",22,[[["self"],["k"],["m"]],["self"]]],[11,"scard","","Get the number of members in a set.",22,[[["self"],["k"]],["self"]]],[11,"sdiff","","Subtract multiple sets.",22,[[["self"],["k"]],["self"]]],[11,"sdiffstore","","Subtract multiple sets and store the resulting set in a key.",22,[[["self"],["k"],["k"]],["self"]]],[11,"sinter","","Intersect multiple sets.",22,[[["self"],["k"]],["self"]]],[11,"sdinterstore","","Intersect multiple sets and store the resulting set in a key.",22,[[["self"],["k"],["k"]],["self"]]],[11,"sismember","","Determine if a given value is a member of a set.",22,[[["self"],["k"],["m"]],["self"]]],[11,"smembers","","Get all the members in a set.",22,[[["self"],["k"]],["self"]]],[11,"smove","","Move a member from one set to another.",22,[[["self"],["k"],["k"],["m"]],["self"]]],[11,"spop","","Remove and return a random member from a set.",22,[[["self"],["k"]],["self"]]],[11,"srandmember","","Get one random member from a set.",22,[[["self"],["k"]],["self"]]],[11,"srandmember_multiple","","Get multiple random members from a set.",22,[[["self"],["k"],["usize"]],["self"]]],[11,"srem","","Remove one or more members from a set.",22,[[["self"],["k"],["m"]],["self"]]],[11,"sunion","","Add multiple sets.",22,[[["self"],["k"]],["self"]]],[11,"sunionstore","","Add multiple sets and store the resulting set in a key.",22,[[["self"],["k"],["k"]],["self"]]],[11,"zadd","","Add one member to a sorted set, or update its score if it already exists.",22,[[["self"],["k"],["m"],["s"]],["self"]]],[11,"zadd_multiple","","Add multiple members to a sorted set, or update its score if it already exists.",22,N],[11,"zcard","","Get the number of members in a sorted set.",22,[[["self"],["k"]],["self"]]],[11,"zcount","","Count the members in a sorted set with scores within the given values.",22,[[["self"],["k"],["m"],["mm"]],["self"]]],[11,"zincr","","Increments the member in a sorted set at key by delta. If the member does not exist, it is added with delta as its score.",22,[[["self"],["k"],["m"],["d"]],["self"]]],[11,"zinterstore","","Intersect multiple sorted sets and store the resulting sorted set in a new key using SUM as aggregation function.",22,N],[11,"zinterstore_min","","Intersect multiple sorted sets and store the resulting sorted set in a new key using MIN as aggregation function.",22,N],[11,"zinterstore_max","","Intersect multiple sorted sets and store the resulting sorted set in a new key using MAX as aggregation function.",22,N],[11,"zlexcount","","Count the number of members in a sorted set between a given lexicographical range.",22,[[["self"],["k"],["l"],["l"]],["self"]]],[11,"zrange","","Return a range of members in a sorted set, by index",22,[[["self"],["k"],["isize"],["isize"]],["self"]]],[11,"zrange_withscores","","Return a range of members in a sorted set, by index with scores.",22,[[["self"],["k"],["isize"],["isize"]],["self"]]],[11,"zrangebylex","","Return a range of members in a sorted set, by lexicographical range.",22,[[["self"],["k"],["m"],["mm"]],["self"]]],[11,"zrangebylex_limit","","Return a range of members in a sorted set, by lexicographical range with offset and limit.",22,[[["self"],["k"],["m"],["mm"],["isize"],["isize"]],["self"]]],[11,"zrevrangebylex","","Return a range of members in a sorted set, by lexicographical range.",22,[[["self"],["k"],["mm"],["m"]],["self"]]],[11,"zrevrangebylex_limit","","Return a range of members in a sorted set, by lexicographical range with offset and limit.",22,[[["self"],["k"],["mm"],["m"],["isize"],["isize"]],["self"]]],[11,"zrangebyscore","","Return a range of members in a sorted set, by score.",22,[[["self"],["k"],["m"],["mm"]],["self"]]],[11,"zrangebyscore_withscores","","Return a range of members in a sorted set, by score with scores.",22,[[["self"],["k"],["m"],["mm"]],["self"]]],[11,"zrangebyscore_limit","","Return a range of members in a sorted set, by score with limit.",22,[[["self"],["k"],["m"],["mm"],["isize"],["isize"]],["self"]]],[11,"zrangebyscore_limit_withscores","","Return a range of members in a sorted set, by score with limit with scores.",22,[[["self"],["k"],["m"],["mm"],["isize"],["isize"]],["self"]]],[11,"zrank","","Determine the index of a member in a sorted set.",22,[[["self"],["k"],["m"]],["self"]]],[11,"zrem","","Remove one or more members from a sorted set.",22,[[["self"],["k"],["m"]],["self"]]],[11,"zrembylex","","Remove all members in a sorted set between the given lexicographical range.",22,[[["self"],["k"],["m"],["mm"]],["self"]]],[11,"zrembyrank","","Remove all members in a sorted set within the given indexes.",22,[[["self"],["k"],["isize"],["isize"]],["self"]]],[11,"zrembyscore","","Remove all members in a sorted set within the given scores.",22,[[["self"],["k"],["m"],["mm"]],["self"]]],[11,"zrevrange","","Return a range of members in a sorted set, by index, with scores ordered from high to low.",22,[[["self"],["k"],["isize"],["isize"]],["self"]]],[11,"zrevrange_withscores","","Return a range of members in a sorted set, by index, with scores ordered from high to low.",22,[[["self"],["k"],["isize"],["isize"]],["self"]]],[11,"zrevrangebyscore","","Return a range of members in a sorted set, by score.",22,[[["self"],["k"],["mm"],["m"]],["self"]]],[11,"zrevrangebyscore_withscores","","Return a range of members in a sorted set, by score with scores.",22,[[["self"],["k"],["mm"],["m"]],["self"]]],[11,"zrevrangebyscore_limit","","Return a range of members in a sorted set, by score with limit.",22,[[["self"],["k"],["mm"],["m"],["isize"],["isize"]],["self"]]],[11,"zrevrangebyscore_limit_withscores","","Return a range of members in a sorted set, by score with limit with scores.",22,[[["self"],["k"],["mm"],["m"],["isize"],["isize"]],["self"]]],[11,"zrevrank","","Determine the index of a member in a sorted set, with scores ordered from high to low.",22,[[["self"],["k"],["m"]],["self"]]],[11,"zscore","","Get the score associated with the given member in a sorted set.",22,[[["self"],["k"],["m"]],["self"]]],[11,"zunionstore","","Unions multiple sorted sets and store the resulting sorted set in a new key using SUM as aggregation function.",22,N],[11,"zunionstore_min","","Unions multiple sorted sets and store the resulting sorted set in a new key using MIN as aggregation function.",22,N],[11,"zunionstore_max","","Unions multiple sorted sets and store the resulting sorted set in a new key using MAX as aggregation function.",22,N],[11,"pfadd","","Adds the specified elements to the specified HyperLogLog.",22,[[["self"],["k"],["e"]],["self"]]],[11,"pfcount","","Return the approximated cardinality of the set(s) observed by the HyperLogLog at key(s).",22,[[["self"],["k"]],["self"]]],[11,"pfmerge","","Merge N different HyperLogLogs into a single one.",22,[[["self"],["k"],["k"]],["self"]]],[11,"publish","","Posts a message to the given channel.",22,[[["self"],["k"],["e"]],["self"]]],[11,"to_redis_args","","This converts the value into a vector of bytes.  Each item is a single argument.  Most items generate a vector of a single item.",27,[[["self"]],["vec",["vec"]]]],[11,"describe_numeric_behavior","","Returns an information about the contained value with regards to it's numeric behavior in a redis context.  This is used in some high level concepts to switch between different implementations of redis functions (for instance `INCR` vs `INCRBYFLOAT`).",27,[[["self"]],["numericbehavior"]]],[11,"is_single_arg","","Returns an indiciation if the value contained is exactly one argument.  It returns false if it's zero or more than one.  This is used in some high level functions to intelligently switch between `GET` and `MGET` variants.",27,[[["self"]],["bool"]]],[11,"from_redis_values","","Similar to `from_redis_value` but constructs a vector of objects from another vector of values.  This primarily exists internally to customize the behavior for vectors of tuples.",26,N]],"paths":[[3,"ConnectionInfo"],[4,"ControlFlow"],[4,"ConnectionAddr"],[4,"ErrorKind"],[4,"NumericBehavior"],[4,"Value"],[8,"ConnectionLike"],[3,"Connection"],[3,"SharedConnection"],[3,"Client"],[3,"Cmd"],[3,"Iter"],[3,"Pipeline"],[3,"Connection"],[3,"PubSub"],[3,"Msg"],[3,"Parser"],[3,"Script"],[3,"ScriptInvocation"],[3,"RedisError"],[3,"InfoDict"],[8,"Commands"],[8,"PipelineCommands"],[8,"PubSubCommands"],[8,"ConnectionLike"],[8,"IntoConnectionInfo"],[8,"FromRedisValue"],[8,"ToRedisArgs"]]};
initSearch(searchIndex);
